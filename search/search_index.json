{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"One template, unlimited possibilities"},{"location":"#create-api-app","title":"Create API App","text":"<p>Create API App is a quickstart tool for building <code>FastAPI</code> applications with a <code>Next.js</code> frontend.</p> <ul> <li> <p> Set up in 5 minutes</p> <p>Install <code>create-api-app</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> Open Source, MIT</p> <p>Create API App is licensed under MIT and available on GitHub</p> <p> License</p> </li> </ul>"},{"location":"customization/","title":"Customization","text":"<p>This section is dedicated to the customization of the project.</p> <p>Access the links on the left to read more!</p>"},{"location":"customization/database/","title":"Changing From MongoDB to SQL","text":"<p>Note</p> <p>This section focuses on updates to the <code>backend</code> directory. Remember to <code>cd</code> into it first!</p> <p>This tool doesn't currently support <code>SQL</code> databases and likely won't do in the future.</p> <p>However, it is still possible to use <code>SQL</code> with the tool, you just need to configure this yourself. We recommend checking out FastAPI's great documentation on how to do this.</p>"},{"location":"customization/database/#cleaning-up-mongodb-files","title":"Cleaning Up MongoDB Files","text":"<p>If you choose this option, you'll need to remove the <code>beanie</code> package from the <code>backend</code>. You can do this by running the poetry remove command while inside the <code>backend</code> directory:</p> <pre><code>poetry remove beanie\n</code></pre> <p>Additionally, you need to update a couple of files inside the <code>app</code> directory:</p> <ul> <li><code>db/__init__.py</code></li> <li><code>main.py</code> - the lifespan method</li> </ul>"},{"location":"customization/database/#db-init-file","title":"DB Init File","text":"<p>Remove <code>all</code> the lines in the file but keep the file there so you can still use the <code>db</code> directory.</p> Why keep the init file? <p><code>__init__.py</code> files tell Python that a folder should be treated as a package so that you can import and use its modules in your code.</p> <p>Starting with <code>Python 3.3</code>, it is not strictly required, but it is still useful for other purposes. You can read more about this in the Python documentation.</p> db/__init__.py<pre><code>from app.models import __beanie_models__\nfrom app.config.settings import settings\n\nfrom beanie import init_beanie\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\n\nasync def init_db() -&gt; None:\n    \"\"\"Initialises the database.\"\"\"\n    client = AsyncIOMotorClient(settings.DB_URL)\n    database = client[settings.DB_NAME]\n    await init_beanie(database=database, document_models=__beanie_models__)\n</code></pre>"},{"location":"customization/database/#the-main-file","title":"The Main File","text":"<p>Remove lines <code>1-3</code> and <code>9-12</code> and update line <code>15</code>.</p> main.py<pre><code>from contextlib import asynccontextmanager\n\nfrom app.db import init_db\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    yield\n\n\napp = FastAPI(docs_url=\"/api/docs\", redoc_url=None, lifespan=lifespan) # (1)!\n\n# app.include_router(root.router, prefix=\"/api\")\n\norigins = [\n    \"\",\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"GET\"],\n    allow_headers=[\"*\"],\n)\n</code></pre> <ol> <li>Remove <code>lifespan=lifespan</code></li> </ol>"},{"location":"customization/styling/","title":"Styling Options","text":"<p>Styling is a big part of any project and if you are a small team or solo developer, it can be difficult to come up with new styling ideas.</p> <p>Here's a few tools that can help spice up your project:</p> <ul> <li>Clerk Themes</li> <li>Shadcn UI Theme Generator</li> <li>Modern Background Snippets</li> </ul>"},{"location":"customization/styling/#future-development","title":"Future Development","text":"<p>In the future, we plan to include different theme styles a bit like <code>DaisyUi</code>.</p> <p>As developers, we want to focus on coding rather than designing!</p>"},{"location":"file-structure/","title":"File Structure","text":"<p>We can categorise the project into three sections:</p> <ul> <li>Root - the files in the root of the <code>project</code> directory</li> <li>Backend - the files in the <code>backend</code> directory</li> <li>Frontend - the files in the <code>frontend</code> directory</li> </ul> <p>You'll mainly be working with the files in <code>backend</code> and <code>frontend</code> directories and likely visit the <code>root</code> files only at the start and end of the projects development.</p>"},{"location":"file-structure/backend/","title":"Backend Files","text":"<p>The <code>backend</code> directory is home to all the <code>FastAPI</code> and <code>Poetry</code> assets.</p> Backend Folder Structure <pre><code>backend\n\u2502   poetry.lock\n\u2502   pyproject.toml\n\u2502   README.md\n\u251c\u2500\u2500\u2500app\n\u2502   \u2502   main.py\n\u2502   \u2502   start.py\n\u2502   \u2502   __init__.py\n\u2502   \u251c\u2500\u2500\u2500config\n\u2502   \u2502       __init__.py\n\u2502   \u2502       settings.py\n\u2502   \u251c\u2500\u2500\u2500db\n\u2502   \u2502       __init__.py\n\u2502   \u251c\u2500\u2500\u2500enums\n\u2502   \u2502       __init__.py\n\u2502   \u251c\u2500\u2500\u2500models\n\u2502   \u2502       __init__.py\n\u2502   \u251c\u2500\u2500\u2500routers\n\u2502   \u2502       __init__.py\n\u2502   \u2514\u2500\u2500\u2500utils\n\u2502           __init__.py\n\u2502           fileloader.py\n\u2514\u2500\u2500\u2500tests\n        __init__.py\n</code></pre>"},{"location":"file-structure/backend/#root-files","title":"Root Files","text":"<p>At the root level, we have three files:</p> <ul> <li><code>README.md</code> - required by <code>Poetry</code>. Holds no real value unless separating the <code>frontend</code> and <code>backend</code></li> <li><code>pyproject.toml</code> - the <code>Poetry</code> configuration file. Has all the information about the project and its packages. We recommend changing the <code>description</code> and <code>author</code> - we don't want credit for a project you've made!</li> <li><code>poetry.lock</code> - the lock file that gets generated by <code>Poetry</code> when running <code>poetry install</code>. It's need to operate <code>Poetry</code> projects and is automatically updated when you use <code>Poetry</code> commands</li> </ul> <p>Warning</p> <p>When changing the <code>name</code> in the <code>pyproject.toml</code> remember to change the <code>app</code> directory name too! These are linked together and are required when building the project for deployment.</p> <p><code>Poetry</code> has some great documentation so remember to check it out if you get stuck on anything!</p>"},{"location":"file-structure/backend/#root-directories","title":"Root Directories","text":"<p>And two directories:</p> <ul> <li><code>app</code> - the application files for <code>FastAPI</code>. This is the home for the <code>Poetry</code> project and the main directory you'll be working in</li> <li><code>tests</code> - a home for your <code>unit and property-based tests</code> created with <code>Hypothesis</code> and <code>Pytest</code></li> </ul>"},{"location":"file-structure/backend/#app-directory","title":"App Directory","text":"<p>The <code>app</code> directory has 2 core files in the root: main.py, start.py.</p> <p>And 6 directories: config, db, enums, models, routers, utils.</p>"},{"location":"file-structure/backend/#mainpy","title":"Main.py","text":"<p>The central piece of the <code>backend</code>. It handles all the functionality for the <code>FastAPI</code> app, including its <code>lifespan</code>, <code>middleware</code>, and <code>router</code> connections.</p> <p>Anything directly connected to the <code>FastAPI</code> app should go in here.</p> Project TemplateWorking Example main.py<pre><code>from contextlib import asynccontextmanager\n\nfrom app.db import init_db\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    yield\n\n\napp = FastAPI(docs_url=\"/api/docs\", redoc_url=None, lifespan=lifespan)\n\n# app.include_router(root.router, prefix=\"/api\")\n\norigins = [\n    \"\",\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"GET\"],\n    allow_headers=[\"*\"],\n)\n</code></pre> main.py<pre><code>from contextlib import asynccontextmanager\n\nfrom app.db import init_db\nfrom app.routers import spells\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    yield\n\n\napp = FastAPI(docs_url=\"/api/docs\", redoc_url=None, lifespan=lifespan)\n\napp.include_router(spells.router, prefix=\"/api\") # (1)!\n\norigins = [\n    \"https://dnd.achronus.dev\", # (2)!\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"GET\"],\n    allow_headers=[\"*\"],\n)\n</code></pre> <ol> <li>Connect our <code>app</code> to the <code>routers</code> directory!</li> <li>Needed to connect the <code>backend</code> to the <code>frontend</code>! Check the FastAPI docs for more details on <code>CORSMiddleware</code></li> </ol>"},{"location":"file-structure/backend/#startpy","title":"Start.py","text":"<p>The entry point for running the <code>uvicorn</code> server. When calling the <code>app-start</code> command in the <code>backend</code> directory, this activates the <code>run</code> function.</p> <p>This file typically won't need to be touched until you are looking at deploying your project. Here's what it looks like:</p> start.py<pre><code>import argparse\n\nimport uvicorn\n\n\ndef run(env_mode: str = \"dev\", host: str = \"127.0.0.1\", port: int = 8000) -&gt; None:\n    \"\"\"Start the server.\"\"\"\n    dev_mode = True if env_mode == \"dev\" else False\n\n    uvicorn.run(\n        \"app.main:app\",\n        host=host,\n        port=port,\n        reload=dev_mode,\n        reload_includes=\"*\",\n    )\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Start the server.\")\n    parser.add_argument(\n        \"-e\", \"--env\", type=str, default=\"dev\", choices=[\"dev\", \"prod\"], required=True\n    )\n    parser.add_argument(\"-ht\", \"--host\", type=str, default=\"127.0.0.1\", required=False)\n    parser.add_argument(\"-pt\", \"--port\", type=int, default=8000, required=False)\n\n    args = parser.parse_args()\n    run(args.env, args.host, args.port)\n</code></pre>"},{"location":"file-structure/backend/#config-directory","title":"Config Directory","text":"<p>This directory is intended for <code>configuration</code> files and <code>constant</code> variables.</p> <p>It houses a critical object for the application called the <code>Settings</code> class in the <code>settings.py</code> file. We use this to access the static <code>config</code> values across the application, such as the <code>database</code> details retrieved from the <code>.env.local</code> file.</p> <p>Here's what it looks like:</p> config/settings.py<pre><code>import os\n\nfrom app.utils.fileloader import FileLoader # (1)!\n\n\nclass Settings:\n    __fileloader = FileLoader()\n\n    DIRPATHS = __fileloader.DIRPATHS\n    FILEPATHS = __fileloader.FILEPATHS\n\n    DB_URL = os.getenv(\"DATABASE_URL\")\n    DB_NAME = \"\"  # Update me!\n    DB_COLLECTION_NAME = \"\"  # Update me!\n\n\nsettings = Settings()  # (2)!\n</code></pre> <ol> <li>Required for loading the <code>DB_URL</code> from the <code>.env.local</code> file</li> <li>We use this to access the <code>settings</code> object in the project!</li> </ol>"},{"location":"file-structure/backend/#db-directory","title":"DB Directory","text":"<p>Houses the <code>database</code> files, such as the connection to the <code>MongoDB</code> database using an <code>AsyncIOMotorClient</code> and the <code>Beanie</code> ODM initalization.</p> <p>It has one file (<code>__init__.py</code>) with this functionality already built in and connected to the <code>FastAPI</code> app.</p> <p>Info</p> <p>Remember the <code>lifespan</code> function in <code>main.py</code>? This connects directly to that!</p> <p>Here's what it looks like:</p> db/__init__.py<pre><code>from app.models import __beanie_models__\nfrom app.config.settings import settings\n\nfrom beanie import init_beanie\nfrom motor.motor_asyncio import AsyncIOMotorClient\n\n\nasync def init_db() -&gt; None:\n    \"\"\"Initialises the database.\"\"\"\n    client = AsyncIOMotorClient(settings.DB_URL)\n    database = client[settings.DB_NAME]\n    await init_beanie(database=database, document_models=__beanie_models__)\n</code></pre>"},{"location":"file-structure/backend/#enums-directory","title":"Enums Directory","text":"<p>This folder is dedicated to Python Enums. These are great to use with Pydantic models for limiting an <code>attribute</code> to predefined <code>options</code>.</p> <p>For example, let's say you have a route that has a set of [query] parameters and you want to limit them to a predefined set of options.</p> What are query parameters? <p>Have you ever seen values after a <code>?</code> in a url, such as <code>page=1</code> or <code>per_page=12</code>?</p> <p>Well, those are <code>query</code> parameters! They are used in <code>frontend</code> applications as a form of <code>state</code>. I'll leave the FastAPI documentation to explain them!</p> <p>You can create an <code>Enum</code> like so:</p> enums/__init__.py<pre><code>from enum import StrEnum\n\n\nclass CommonQueryKeys(StrEnum):\n    \"\"\"An enum for common query keys.\"\"\"\n\n    LIMIT = \"limit\"\n    SKIP = \"skip\"\n</code></pre>"},{"location":"file-structure/backend/#models-directory","title":"Models Directory","text":"<p>This folder houses your Pydantic and Beanie models. You'll be here a lot!</p> <p>The <code>Beanie</code> models focus on representing what the <code>MongoDB</code> database looks like, while the <code>Pydantic</code> models are used for handling data.</p> Beanie Models Project TemplateReal Example models/__init__.py<pre><code>from typing import Optional\n\nfrom app.config.settings import settings\n\nfrom beanie import Document\nfrom pydantic import BaseModel\n\n\nclass ExampleDB(Document):\n    \"\"\"\n    The main model for your database collection. \n    Should represent the structure of the data in the collection.\n\n    For more details check the [Beanie docs](https://beanie-odm.dev/).\n    \"\"\"\n\n    name: str\n    desc: Optional[str] = None\n\n    class Settings:\n        name = settings.DB_COLLECTION_NAME\n\n\n__beanie_models__ = [ExampleDB]\n</code></pre> models/__init__.py<pre><code>from typing import Optional\n\nfrom app.config.settings import settings\n\nfrom beanie import Document\nfrom pydantic import BaseModel\n\n\nclass DBSpellDetails(Document, CoreDetails):\n    \"\"\"The spell detail representation in the database.\"\"\"\n\n    desc: list[str]\n    higher_level: list[str]\n    range: str\n    components: list[str]\n    ritual: bool\n    duration: str\n    concentration: bool\n    casting_time: str\n    level: int\n    damage: Optional[DamageType] = None\n    dc: Optional[DCType] = None\n    school: CoreDetails\n    classes: list[CoreDetails]\n    subclasses: list[CoreDetails]\n\n    class Settings:\n        name = settings.DB_SPELLS_COLLECTION\n\n\n__beanie_models__ = [DBSpellDetails]\n</code></pre> Pydantic Models DB ExampleRoute Example <p>These models connect to the <code>DBSpellDetails</code> document in the <code>Beanie Models - Real Example</code>!</p> models/__init__.py<pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass CoreDetails(BaseModel):\n    index: str\n    name: str\n    url: str\n\n\nclass DamageType(BaseModel):\n    damage_type: Optional[CoreDetails] = None\n    damage_at_character_level: Optional[dict[str, str]] = None\n\n\nclass DCType(BaseModel):\n    dc_type: dict[str, str]\n    dc_success: str\n</code></pre> <p>We use some of these in the routers example!</p> models/routing.py<pre><code>from typing import Optional\n\nfrom app.enums import (\n    Classes,\n    Components,\n    DamageTypes,\n    Levels,\n    MagicSchools,\n    Subclasses,\n)\nfrom app.models import CoreDetails, DCType, DamageType\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass SpellOverviewInput(BaseModel):\n    \"\"\"A model that represents the query parameters for the `spells_overview` route.\"\"\"\n\n    limit: Optional[int] = None\n    skip: Optional[int] = None\n    classes: Optional[Classes] = None\n    subclass: Optional[Subclasses] = None \n    components: Optional[Components] = None # (1)!\n    level: Optional[Levels] = None\n    school: Optional[MagicSchools] = None\n    damage_type: Optional[DamageTypes] = None\n\n    model_config = ConfigDict(use_enum_values=True)\n\n\nclass SpellNames(BaseModel):\n\"\"\"A model for retrieving all the spell names.\"\"\"\n\nname: str\n\n\nclass SpellDetailsResponse(BaseModel):\n    \"\"\"A model that represents the spell details for each spell.\"\"\"\n\n    name: str\n    index: str\n    desc: list[str]\n    higher_level: list[str]\n    range: str\n    components: list[str]\n    ritual: bool\n    duration: str\n    concentration: bool\n    casting_time: str\n    level: int\n    damage: Optional[DamageType] = None\n    dc: Optional[DCType] = None\n    school: CoreDetails\n    classes: list[CoreDetails]\n    subclasses: list[CoreDetails]\n</code></pre> <ol> <li>These use Python <code>Enums</code>!</li> </ol>"},{"location":"file-structure/backend/#routers-directory","title":"Routers Directory","text":"<p>This directory houses all the <code>FastAPI routes</code> by making use of the <code>APIRouter</code>.</p> <p>For example, let's say we have a set of <code>spells</code> in our database and we want to create two routes:</p> <ul> <li>One to pull a list of their <code>names</code> from the database. Accessed at the url - <code>/api/spells/names</code></li> <li>And another for accessing each spells information individually using their <code>index</code>. Accessable at the url - <code>/api/spells/{index}</code></li> </ul> <p>We can do this easily by creating a <code>spells</code> router, assigning it the <code>/spells</code> prefix and then attach our routes using its name.</p> <p>Here's what that would look like:</p> routers/spells.py<pre><code>from app.models import DBSpellDetails\nfrom app.models.local import SpellNames, SpellDetailsResponse\n\nfrom fastapi import HTTPException, APIRouter\n\n\nrouter = APIRouter(prefix=\"/spells\", tags=[\"spells\"]) # (1)!\n\n\n@router.get(\"/names\", response_model=list[SpellNames] | list[str]) # (2)!\nasync def spell_names():\n    result = await DBSpellDetails.find_all().to_list()\n\n    if result is None:\n        raise HTTPException(status_code=404, detail=\"Cannot retrieve data.\")\n\n    names = [\"-\".join(name.name.lower().split(\" \")) for name in result]\n    return names\n\n\n@router.get(\"/{index}\", response_model=SpellDetailsResponse) # (3)!\nasync def spell_details(index: str):\n    result = await DBSpellDetails.find_one(DBSpellDetails.index == index)\n\n    if result is None:\n        raise HTTPException(status_code=404, detail=\"Item not found.\")\n\n    return result\n</code></pre> <ol> <li>Create a <code>router</code> using the <code>APIRouter</code></li> <li>Create our first route that points to <code>/api/spells/names</code></li> <li>Create our second route that points to <code>/api/spells/{index}</code></li> </ol> <p>Now we just need to go back into the <code>main.py</code> file and connect it to our <code>app</code>!</p> app/main.py<pre><code># Imports and other config\n# ...\n\napp.include_router(spells.router, prefix=\"/api\") # (1)!\n\n# Origins\n# ...\n</code></pre> <ol> <li>Notice the <code>prefix</code>? This prepends <code>/api</code> to the <code>spells</code> router to make it direct to <code>api/spells/</code>!</li> </ol>"},{"location":"file-structure/backend/#utils-directory","title":"Utils Directory","text":"<p>A place to store <code>utility</code> functions.</p> <p>It comes preconfigured with a <code>Fileloader</code> class for finding and loading the <code>.env.local</code> file used in <code>config/settings.py</code> for retrieving the <code>DB_URL</code>. You don't need to amend this file.</p>"},{"location":"file-structure/frontend/","title":"Frontend Files","text":"<p>The <code>frontend</code> directory is home to all the <code>Next.js</code> and <code>React</code> assets.</p> Frontend Folder Structure <pre><code>frontend\n\u2502   .eslintrc.json\n\u2502   components.json\n\u2502   next.config.mjs\n\u2502   next-env.d.ts\n\u2502   package.json\n\u2502   postcss.config.mjs\n\u2502   tailwind.config.ts\n\u2502   tsconfig.json\n\u251c\u2500\u2500\u2500public\n\u2514\u2500\u2500\u2500src\n    \u251c\u2500\u2500\u2500app\n    \u2502   \u2502   favicon.ico\n    \u2502   \u2502   globals.css\n    \u2502   \u2502   layout.tsx\n    \u2502   \u2502   page.tsx\n    \u2502   \u2502\n    \u2502   \u2514\u2500\u2500\u2500api\n    \u2502       \u2514\u2500\u2500\u2500uploadthing\n    \u2502           \u2514\u2500\u2500\u2500list-files\n    \u2502                   route.ts\n    \u251c\u2500\u2500\u2500components\n    \u251c\u2500\u2500\u2500data\n    \u251c\u2500\u2500\u2500hooks\n    \u2502       useFetchData.tsx\n    \u2502       useFetchImgs.tsx\n    \u251c\u2500\u2500\u2500layouts\n    \u251c\u2500\u2500\u2500lib\n    \u2502       constants.ts\n    \u2502       queries.ts\n    \u2502       utils.ts\n    \u251c\u2500\u2500\u2500pages\n    \u2502   \u2514\u2500\u2500\u2500Homepage\n    \u2502           Homepage.tsx\n    \u2502           index.tsx\n    \u2514\u2500\u2500\u2500types\n            api.ts\n</code></pre>"},{"location":"file-structure/frontend/#root-files","title":"Root Files","text":"<p>At the root level, we have numerous <code>configuration</code> files:</p> <ul> <li><code>.eslintrc.json</code> - the config file for <code>eslint</code>. Typically, you won't ever need to touch this</li> <li><code>components.json</code> - the config file for <code>Shadcn/ui</code>. We recommend changing the <code>style</code> and <code>baseColor</code> in this file to your preference</li> <li><code>next.config.mjs</code> - the config file for <code>Next.js</code>. We'll discuss this in more detail shortly</li> <li><code>next-env.d.ts</code> - a <code>Typescript</code> declaration file for <code>Next.js</code>. This file is automatically generated and does not need to be modified</li> <li><code>package.json</code> - the package management file for <code>Node</code>. It contains a list of all the projects <code>dependencies</code> and commands that can be run</li> <li><code>postcss.config.mjs</code> - the config file for <code>postcss</code>. This is installed by default with <code>Tailwind CSS</code></li> <li><code>tailwind.config.ts</code> - the config file for <code>Tailwind CSS</code>. You'll likely visit this file occassionally for adding custom theme styles. You can read more about it in their documentation</li> <li><code>tsconfig.json</code> - the config file for <code>TypeScript</code></li> </ul>"},{"location":"file-structure/frontend/#next-config","title":"Next Config","text":"<p>We've preconfigured the <code>next.config.mjs</code> file to extract the environment variables from <code>.env.local</code> and automatically apply them to the project.</p> <p>As you'll see in the file, whenever you need to access an <code>environment</code> variable you can use <code>process.env.&lt;variable_name&gt;</code>.</p> <p>Additionally, we've configured it to automatically redirect to the <code>FastAPI</code> backend to easy fetch the JSON data provided by your routes when using <code>/api/&lt;path&gt;</code>.</p> <p>Unless you have something specific in mind, you don't need to configure this file any further.</p> <p>Here's what it looks like:</p> next.config.mjs<pre><code>/** @type {import('next').NextConfig} */\n\nimport path from \"path\";\nimport dotenv from \"dotenv\";\nimport dotenvExpand from \"dotenv-expand\";\n\nconst loadEnv = (filePath) =&gt; {\n  const env = dotenv.config({ path: filePath });\n  dotenvExpand.expand(env);\n};\n\nloadEnv(path.resolve(process.cwd(), \".env.local\"));\n\nconst apiUrl = process.env.FASTAPI_CONNECTION_URL;\n\nconst nextConfig = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: \"https\",\n        hostname: \"utfs.io\",\n        pathname: `/a/${process.env.NEXT_PUBLIC_UPLOADTHING_APP_ID}/*`,\n      },\n      {\n        protocol: \"https\",\n        hostname: apiUrl,\n        pathname: `/api/*`,\n      },\n    ],\n  },\n  rewrites: async () =&gt; {\n    return [\n      {\n        source: \"/api/:path*\",\n        destination: `${apiUrl}/api/:path*`,\n      },\n      {\n        source: \"/docs\",\n        destination: `${apiUrl}/docs`,\n      },\n      {\n        source: \"/openapi.json\",\n        destination: `${apiUrl}/openapi.json`,\n      },\n    ];\n  },\n};\n\nexport default nextConfig;\n</code></pre>"},{"location":"file-structure/frontend/#directories","title":"Directories","text":"<p>There are two directories:</p> <ul> <li><code>public</code> - a place to store static files, such as images. This allows referencing to images from the base URL (<code>/</code>). You can read more about it in the Next.js documentation</li> <li><code>src</code> - the root directory for all your applications source code. It helps to separate your application code from the configuration files. You can think of it as the heart of the <code>frontend</code>. We'll discuss this next</li> </ul>"},{"location":"file-structure/frontend/#source-directory","title":"Source Directory","text":"<p>The <code>src</code> directory is made up of multiple sub-directories.</p> <p>There are 8 in total: <code>app</code>, <code>components</code>, <code>data</code>, <code>hooks</code>, <code>layouts</code>, <code>lib</code>, <code>pages</code>, <code>types</code>.</p>"},{"location":"file-structure/frontend/#app","title":"App","text":"<p>The <code>app</code> directory handles the functionality for Next.js routing.</p> <p>it contains <code>four</code> files and <code>one</code> directory:</p> <ul> <li><code>favicon.ico</code> - the favicon icon for the website</li> <li><code>globals.css</code> - the global CSS file applied to the whole project</li> <li><code>layout.tsx</code> - the root layout of the pages used in the project</li> <li><code>page.tsx</code> - the root page for the project (<code>/</code>). We've configured this to use the <code>Homepage</code> directory from the <code>pages</code> directory. We'll explore this in more detail later</li> <li><code>api</code> - the directory for handling <code>Next.js API</code> routes</li> </ul> <p>You'll primarily focus on editing the <code>layout.tsx</code> and <code>page.tsx</code> files in this directory. However, we advise you to replace the <code>favicon.ico</code> when you first use the project with your own custom one.</p> <p><code>globals.css</code> is already configured with <code>Tailwind CSS</code>. If you need to use CSS outside of the Tailwind's styles, we recommend using CSS modules.</p> <p>Here's what the files look like:</p> app/globals.cssapp/layout.tsxapp/page.tsx <pre><code>@import url(\"https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300..900;1,300..900&amp;display=swap\");\n\n@tailwind base; // (1)!\n@tailwind components;\n@tailwind utilities;\n</code></pre> <ol> <li>Preconfigured with the <code>Rubik</code> font!</li> </ol> <pre><code>import type { Metadata } from \"next\";\nimport { Rubik } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst rubik = Rubik({ subsets: [\"latin\"] });\n\nexport const metadata: Metadata = {\n  title: \"&lt;TITLE_HERE&gt;\", // (1)!\n  description: \"&lt;DESCRIPTION_HERE&gt;\", // (2)!\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly&lt;{\n  children: React.ReactNode;\n}&gt;) {\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;body\n        className={`${rubik.className} min-h-screen flex flex-col`}\n      &gt;\n        {children}\n      &lt;/body&gt;\n    &lt;/html&gt;\n  );\n}\n</code></pre> <ol> <li>The <code>title</code> of your website</li> <li>The <code>description</code> of your website</li> </ol> <pre><code>import Homepage from \"@/pages/Homepage\";\nimport { Suspense } from \"react\";\n\nexport default function Home() {\n  return (\n    &lt;Suspense fallback={&lt;&gt;&lt;/&gt;}&gt;\n      &lt;Homepage /&gt;\n    &lt;/Suspense&gt;\n  );\n}\n</code></pre>"},{"location":"file-structure/frontend/#api","title":"API","text":"<p>Most of our routing is performed using the <code>FastAPI backend</code> but sometimes you may need to create routes using the <code>frontend</code>.</p> <p><code>uploadthing</code> is a prime example of this. It only has <code>JavaScript</code> support and thus <code>cannot</code> be fetched using <code>Python</code>. So instead, we use the <code>frontend</code>.</p> <p>We've preconfigured the template with direct access to <code>uploadthing</code> using the <code>/api/uploadthing/list-files</code> route. To use it, simply call the <code>useFetchImgs</code> hook in your component. You can read more about it in the <code>hooks</code> section.</p> <p>For those interested, here's what the <code>route</code> looks like:</p> api/uploadthing/list-files/route.ts<pre><code>import { NextRequest, NextResponse } from \"next/server\";\nimport { UTApi } from \"uploadthing/server\";\n\nconst utapi = new UTApi({\n  apiKey: process.env.UPLOADTHING_SECRET, // (1)!\n});\n\nexport async function GET(req: NextRequest) {\n  try {\n    const imgData = await utapi.listFiles();\n\n    let filenames: string[] = [];\n    let imgUrls: string[] = [];\n\n    const url = req.nextUrl;\n    if (url.searchParams.has(\"filenames\")) {\n      filenames = (url.searchParams.get(\"filenames\") as string).split(\",\");\n\n      filenames.forEach((name) =&gt; {\n        const file = imgData.files.find(\n          (file) =&gt; file.name.split(\".\")[0] === name\n        );\n        if (file) {\n          imgUrls.push(file.key);\n        }\n      });\n\n      if (imgUrls.length === 0) {\n        return NextResponse.json({ message: \"No files found.\" });\n      }\n      return NextResponse.json(imgUrls);\n    }\n    return NextResponse.json({ message: \"Missing query parameters.\" });\n  } catch (error: any) {\n    return NextResponse.json({\n      message: \"Unable to fetch files.\",\n      error: error,\n    });\n  }\n}\n</code></pre> <ol> <li>Connects directly to the <code>uploadthing</code> bucket</li> </ol>"},{"location":"file-structure/frontend/#components","title":"Components","text":"<p>The <code>components</code> directory houses all your global reusable <code>React</code> components that are shared across the project.</p> <p>For example, when you add <code>Shadcn/ui</code> components using their CLI they can be found here inside a <code>ui</code> directory in this folder.</p>"},{"location":"file-structure/frontend/#data","title":"Data","text":"<p>A place to store all your static <code>data</code> arrays.</p> <p>For example, let's say you have a list of categories in the form of <code>select</code> boxes that you want to display on your website, but need them to connect to the <code>backend</code> to retrieve the available options.</p> <p>You can do something like this:</p> data/details.ts<pre><code>import { CategoryDetails } from \"@/types/option\";\n\nexport const SpecialisationDetails: CategoryDetails[] = [\n  {\n    name: \"class\", // (1)!\n    heading: \"What class?\",  // (2)!\n    queryKey: \"classes\",  // (3)!\n  },\n  {\n    name: \"subclass\",\n    heading: \"What sub-class?\",\n    queryKey: \"subclass\",\n  },\n  {\n    name: \"school\",\n    heading: \"What school?\",\n    queryKey: \"school\",\n  },\n];\n</code></pre> <ol> <li>A <code>name</code> to differentiate and assign the correct information to each <code>select</code> box</li> <li>A <code>heading</code> for identify what each <code>select</code> box contains</li> <li>A <code>queryKey</code> to assign to the URL when the input is selected. E.g., if we have a class input of <code>barbarian</code> our query would be <code>?classes=barbarian</code></li> </ol> Why use query keys? <p>Query keys are great for storing <code>state</code> in the URL. In this case, we can directly pass this information back to our <code>FastAPI</code> backend which can retrieve the desired data from the database.</p> <p>Interested in learning more about <code>URL state</code>? ByteGrad offers a great YouTube video on the topic. </p>"},{"location":"file-structure/frontend/#hooks","title":"Hooks","text":"<p>The <code>hooks</code> folder houses your custom hooks that are used globally throughout your <code>Next.js</code> project.</p> <p>The project comes preconfigured with two of them: useFetchData, useFetchImgs</p>"},{"location":"file-structure/frontend/#usefetchdata","title":"useFetchData","text":"<p>This hook uses the Next.js FetchAPI to retrieve data from a <code>URL</code> with an optional set of <code>options</code>. It returns the received <code>data</code>, an <code>isLoading</code> flag and an <code>error</code> object (if any).</p> hooks/useFetchData.tsx<pre><code>import { useEffect, useState } from \"react\";\n\nconst useFetchData = &lt;T,&gt;(url: string, options: object = {}) =&gt; {\n  const [data, setData] = useState&lt;T | null&gt;(null);\n  const [isLoading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    if (!url) {\n      return;\n    }\n\n    const fetchData = async (url: string, options: object = {}) =&gt; {\n      try {\n        const response = await fetch(url, options);\n\n        if (response.ok) {\n          const result = await response.json();\n          setData(result);\n        }\n      } catch (error: any) {\n        console.error(\"Error fetching data:\", error);\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData(url, options);\n  }, [url]);\n\n  return { data, isLoading, error };\n};\n\nexport default useFetchData;\n</code></pre> <p>It's extremely easy to use straight out of the box. Simply call it inside a component with a URL and a specified type.</p> <p>Here's a simple example:</p> Example usage<pre><code>\"use client\";\n\nimport useFetchData from \"@/hooks/useFetchData\";\n\ntype SpellData = {\n  counts: int;\n  results: object[];\n}\n\n\nconst CantripSpells = () =&gt; {\n  const {data, isLoading, error} = useFetchData&lt;SpellData&gt;(\n    \"https://www.dnd5eapi.co/api/spells?level=0\"\n  );\n\n  return (\n    &lt;div&gt;\n      {data?.results.map((item)) =&gt; (\n        // JSX\n        // ....\n      ))}\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"file-structure/frontend/#usefetchimgs","title":"useFetchImgs","text":"<p>This hook uses the <code>useFetchData</code> hook with a predefined URL to extract <code>names</code> and <code>images</code> from the custom <code>uploadthing/list-files</code> route.</p> hooks/useFetchImgs.tsx<pre><code>import { UTListFileUrl } from \"@/lib/constants\";\nimport { zip } from \"@/lib/utils\";\nimport { UTImage } from \"@/types/api\";\nimport { useEffect, useState } from \"react\";\nimport useFetchData from \"./useFetchData\";\n\n\nconst useFetchImgs = (imgNames: string) =&gt; {\n  const [imgData, setImgData] = useState&lt;UTImage[]&gt;([]);\n\n  const { data, isLoading, error } = useFetchData(\n    `${UTListFileUrl}?filenames=${imgNames}`,\n    {\n      headers: {\n        Accept: \"application/json\",\n        method: \"GET\",\n      },\n    }\n  );\n\n  useEffect(() =&gt; {\n    if (!imgNames) {\n      return;\n    }\n\n    if (data) {\n      const urlTemplate = `https://utfs.io/a/${process.env.NEXT_PUBLIC_UPLOADTHING_APP_ID}`;\n\n      const result = zip(imgNames.split(\",\"), data);\n\n      let imgUrls: UTImage[] = [];\n      result.map(([name, url]) =&gt; {\n        imgUrls.push({\n          name: name,\n          url: `${urlTemplate}/${url}`,\n        });\n      });\n\n      setImgData(imgUrls);\n    }\n  }, [imgNames, data]);\n\n  return { imgData, isLoading, error };\n};\n\nexport default useFetchImgs;\n</code></pre> <p>Like the other hooks, it works straight out of the box. Just give it a string of filenames, separated by commas, that exist in the <code>uploadthing</code> bucket attached to the project through its <code>API keys</code>.</p> <p>You'll then get an array of objects with <code>names</code> and <code>urls</code> that can be allocated to <code>Next.js Image</code> components.</p> <p>Here's an example:</p> Example usage<pre><code>\"use client\";\n\nimport useFetchImgs from \"@/hooks/useFetchImgs\";\n\n\nconst SpellImages = () =&gt; {\n  const {imgData, isLoading, error} = useFetchImgs(\n    \"wall-of-stone,acid-arrow\"\n  );\n\n  return (\n    &lt;div&gt;\n      {imgData?.map((img)) =&gt; (\n        &lt;Image\n          src={img.url}\n          alt={img.name}\n          fill\n        /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"file-structure/frontend/#layouts","title":"Layouts","text":"<p>A directory for storing <code>layout</code> based components such as, <code>Heading</code>, <code>Footer</code>, <code>Navbar</code>, and <code>Sidebar</code>.</p> <p>Layouts are often built using multiple components and are integral pieces of your project for providing structure. Because of their importance, we find it easier to have them allocated to a separate folder for quick and easy access!</p>"},{"location":"file-structure/frontend/#lib","title":"Lib","text":"<p>The <code>lib</code> directory contains global application-specific files. These could include <code>utility</code> functions, <code>constants</code>, facades and more.</p> <p>We've preconfigured this with a few files: <code>constants.ts</code>, <code>queries.ts</code>, <code>utils.ts</code>.</p>"},{"location":"file-structure/frontend/#constants","title":"Constants","text":"<p>Theres only one constant added to the project and thats the <code>uploadthing</code> route path used to access the <code>uploadthing/list-files</code> route.</p> <p>We use this in the <code>useFetchImgs</code> hook.</p> lib/constants.ts<pre><code>export const UTListFileUrl = \"/api/uploadthing/list-files\";\n</code></pre>"},{"location":"file-structure/frontend/#queries","title":"Queries","text":"<p>We've added two query specific utility functions to the project:</p> <ul> <li><code>addQueries</code> - <code>adds</code> an array of URL queries to the values extracted from the <code>useSearchParams()</code> hook and converts them into a string prepended with a <code>?</code></li> <li><code>removeQueries</code> - <code>removes</code> an array of URL queries from the values extracted from the <code>useSearchParams()</code> hook and converts them into a string prepended with a <code>?</code></li> </ul> FunctionsaddQueries ExampleremoveQueries Example lib/queries.ts<pre><code>import { ReadonlyURLSearchParams } from \"next/navigation\";\n\nexport const addQueries = (\n  searchParams: ReadonlyURLSearchParams | null,\n  queries: { name: string; value: string }[]\n) =&gt; {\n  const params = searchParams\n    ? new URLSearchParams(searchParams.toString())\n    : new URLSearchParams();\n\n  queries.forEach(({ name, value }) =&gt; {\n    params.set(name, value);\n  });\n\n  return `?${params.toString()}`;\n};\n\n\nexport const removeQueries = (\n  searchParams: ReadonlyURLSearchParams | null,\n  queryNames: string[]\n) =&gt; {\n  const params = searchParams\n    ? new URLSearchParams(searchParams.toString())\n    : new URLSearchParams();\n\n  queryNames.forEach((query) =&gt; {\n    params.delete(query);\n  });\n\n  return `?${params.toString()}`;\n};\n</code></pre> components/example.tsx<pre><code>\"use client\";\n\nimport { addQueries } from \"@/lib/queries\";\nimport { useSearchParams } from \"next/navigation\";\n\nconst Example = () =&gt; {\n  const searchParams = useSearchParams();\n\n  const newParams = addQueries(searchParams, [\n    { name: \"limit\", value: \"10\" },\n    { name: \"skip\", value: \"5\" },\n  ]);\n\n  return (\n    &lt;div&gt;\n      {/* JSX */}\n      {/* ... */}\n    &lt;/div&gt;\n  );\n};\n\nexport default Example;\n</code></pre> components/example.tsx<pre><code>\"use client\";\n\nimport { removeQueries } from \"@/lib/queries\";\nimport { useSearchParams } from \"next/navigation\";\n\nconst Example = () =&gt; {\n  const searchParams = useSearchParams();\n\n  const newParams = removeQueries(searchParams, [\n    \"limit\",\n    \"skip\",\n  ]);\n\n  return (\n    &lt;div&gt;\n      {/* JSX */}\n      {/* ... */}\n    &lt;/div&gt;\n  );\n};\n\nexport default Example;\n</code></pre>"},{"location":"file-structure/frontend/#utils","title":"Utils","text":"<p>We've added three utility functions to the project:</p> <ul> <li><code>cn</code> - a function for handling <code>Tailwind CSS</code> classes and compressing them into a single string</li> <li><code>zip</code> - a <code>JavaScript</code> representation of the <code>Python</code> <code>zip</code> function. Allowing iteration over several arrays simultaneously</li> <li><code>title</code> - a lightweight function that uppercases the first value in a string</li> </ul> lib/utils.ts<pre><code>import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function zip(...arrays: any[]) {\n  const minLength = Math.min(...arrays.map((arr) =&gt; arr.length));\n  return Array.from({ length: minLength }, (_, i) =&gt;\n    arrays.map((array) =&gt; array[i])\n  );\n}\n\nexport function title(item: string) {\n  return item[0].toUpperCase() + item.substring(1, item.length);\n}\n</code></pre>"},{"location":"file-structure/frontend/#pages","title":"Pages","text":"<p>The <code>pages</code> directory is used to store your applications webpages.</p> <p>Pages are often made up of a little bit of everything. These can be as simple as a <code>.tsx</code> file or a subdirectory with its own unique components.</p> <p>It comes preconfigured with a <code>Homepage</code> directory and <code>Homepage.tsx</code> file. We recommend starting here when first using the template! It connects directly to the <code>app/page.tsx</code> file.</p> <p>Info</p> <p>We use an <code>index.tsx</code> file to keep the import statements tidy! Here's the difference with and without an <code>index.tsx</code> file:</p> <pre><code>import Homepage from \"@/pages/Homepage/Homepage\"; // without\nimport Homepage from \"@/pages/Homepage\"; // with\n</code></pre> <p>This is what the starting template looks like:</p> Homepage/Homepage.tsx<pre><code>type Props = {};\n\nconst Homepage = ({}: Props) =&gt; {\n  return (\n    &lt;main&gt;\n      &lt;section&gt;&lt;/section&gt;\n    &lt;/main&gt;\n  );\n};\n\nexport default Homepage;\n</code></pre>"},{"location":"file-structure/frontend/#types","title":"Types","text":"<p>The <code>types</code> directory contains all the global <code>TypeScript</code> types for the project.</p> <p>As your project grows, so will your <code>TypeScript</code> types. It's often better to keep them in one location and categoried into separate files for better project management.</p> <p>We've preconfigured it with a single type <code>UTImage</code>. This connects to our custom <code>uploadthing</code> <code>useFetchImgs</code> hook.</p> <p>Here's what it looks like:</p> types/api.ts<pre><code>export type UTImage = {\n  name: string;\n  url: string;\n};\n</code></pre>"},{"location":"file-structure/root/","title":"Root Files","text":"<p>In the root of the <code>project</code> there are only three files to worry about.</p> <ul> <li><code>.env.local</code> - a file for the environment variables (API keys and database url)</li> <li><code>.gitignore</code> - the ignore file for GitHub</li> <li><code>README.md</code> - a markdown file for explaining what your project is about</li> </ul> Project Root<pre><code>root\n\u251c\u2500\u2500\u2500backend\n\u2502   \u2502   ...\n\u2514\u2500\u2500\u2500frontend\n\u2502   \u2502   ...\n\u2502   .env.local\n\u2502   .gitignore\n\u2502   README.md\n</code></pre>"},{"location":"file-structure/root/#environment-file","title":"Environment File","text":"<p><code>.env.local</code> is one of those files you use at the start of your project to configure it and then tweak it again just before deployment.</p> <p>We've tried to make configuration as easy as possible and added comments in the file with links to each tool so you can start configuring your API keys immediately.</p> <p>Here's what it looks like:</p> .env.local<pre><code># The URL to connect FastAPI and NextJS together - used in `frontend/next.config.mjs`\nFASTAPI_CONNECTION_URL=http://127.0.0.1:8000/\n\n# MongoDB: The connection url to your database\n# https://www.mongodb.com/\nDB_URL=\n\n# Uploadthing: storing files and handling file uploading\n# https://uploadthing.com/\nUPLOADTHING_SECRET=\nNEXT_PUBLIC_UPLOADTHING_APP_ID=\n\n# Clerk: User Authentication\n# https://clerk.com/docs/quickstarts/nextjs\nNEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=\nCLERK_SECRET_KEY=\n\nNEXT_PUBLIC_CLERK_SIGN_IN_URL=/auth/sign-in\nNEXT_PUBLIC_CLERK_SIGN_UP_URL=/auth/sign-up\nNEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/\nNEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/\n\n# Stripe: user payments\n# https://stripe.com/docs\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=\nSTRIPE_SECRET_KEY=\nSTRIPE_WEBHOOK_SECRET=\nNEXT_PUBLIC_STRIPE_CLIENT_ID=\nNEXT_PUBLIC_PLATFORM_SUBSCRIPTION_PERCENT=1\nNEXT_PUBLIC_PLATFORM_ONETIME_FEE=2\nNEXT_PUBLIC_PLATFORM_PERCENT=1\nNEXT_PRODUCT_ID=\n</code></pre>"},{"location":"file-structure/root/#gitignore","title":"Gitignore","text":"<p>The <code>.gitignore</code> file is used when pushing files to a GitHub repository. Any files or directories defined inside it, are ignored within git commits. This is useful for preventing unnecessary files (such as <code>node_modules</code>), or ones that contain sensitive information (such as <code>.env.local</code>), from ending up in your repo.</p> <p>We've preconfigured and tailored the <code>.gitignore</code> file to the project already to help you jump straight into project development.</p>"},{"location":"file-structure/root/#readme","title":"Readme","text":"<p>The <code>README.md</code> acts as the face of your GitHub repository. It's where you put all your information about the project you've created, how to install it and run it, etc.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Create API App is a predefined application template for creating projects with a <code>FastAPI</code> backend and <code>Next.js</code> frontend.</p>"},{"location":"getting-started/#the-stack","title":"The Stack","text":""},{"location":"getting-started/#backend","title":"Backend","text":"<ul> <li> FastAPI for API routing</li> <li> Pydantic for data validation</li> <li> MongoDB for database storage</li> <li> Beanie an ODM for MongoDB</li> <li> Poetry for package management</li> <li> Pytest for unit testing</li> <li> Hypothesis for property based testing</li> </ul>"},{"location":"getting-started/#frontend","title":"Frontend","text":"<ul> <li> Next.js our React framework</li> <li> Tailwind CSS for utility styling</li> <li> TypeScript for data type validation</li> <li> Uploadthing for file management</li> <li> Clerk for user authentication</li> <li> Stripe for payments</li> <li> Lucide React for icons</li> <li> Shadcn/ui our component library</li> </ul>"},{"location":"getting-started/configure/","title":"Configuring The Project","text":"<p>Each project can be configured in three easy steps:</p> <ol> <li>Update your API keys and database URL</li> <li>Update the database details in the <code>settings.py</code> file</li> <li>Update the <code>ExampleDB</code> model to match your database collection</li> </ol>"},{"location":"getting-started/configure/#updating-your-api-keys","title":"Updating Your API Keys","text":"<p>Inside the <code>root</code> directory access the <code>.env.local</code> file and follow the links to get your API keys. Simply add them at their corresponding location.</p> <p>The file will look something like this:</p> <p>Note</p> <p>Some API keys may be missing depending on the packages you have <code>excluded</code>.</p> .env.local<pre><code># The URL to connect FastAPI and NextJS together - used in `frontend/next.config.mjs`\nFASTAPI_CONNECTION_URL=http://127.0.0.1:8000/\n\n# MongoDB: The connection url to your database\n# https://www.mongodb.com/\nDB_URL=\n\n# Uploadthing: storing files and handling file uploading\n# https://uploadthing.com/\nUPLOADTHING_SECRET=\nNEXT_PUBLIC_UPLOADTHING_APP_ID=\n\n# Clerk: User Authentication\n# https://clerk.com/docs/quickstarts/nextjs\nNEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=\nCLERK_SECRET_KEY=\n\nNEXT_PUBLIC_CLERK_SIGN_IN_URL=/auth/sign-in\nNEXT_PUBLIC_CLERK_SIGN_UP_URL=/auth/sign-up\nNEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/\nNEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/\n\n# Stripe: user payments\n# https://stripe.com/docs\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=\nSTRIPE_SECRET_KEY=\nSTRIPE_WEBHOOK_SECRET=\nNEXT_PUBLIC_STRIPE_CLIENT_ID=\nNEXT_PUBLIC_PLATFORM_SUBSCRIPTION_PERCENT=1\nNEXT_PUBLIC_PLATFORM_ONETIME_FEE=2\nNEXT_PUBLIC_PLATFORM_PERCENT=1\nNEXT_PRODUCT_ID=\n</code></pre>"},{"location":"getting-started/configure/#updating-database-details","title":"Updating Database Details","text":"<p>Navigate to <code>backend/app/config/settings.py</code> and then update the <code>DB_NAME</code> and <code>DB_COLLECTION_NAME</code> to reflect your MongoDB database.</p> Databases and Collections <p>Collections are just a fancy way of saying a <code>table</code>. You can read more about them in the MongoDB documentation.</p> config/settings.py<pre><code>import os\n\nfrom app.utils.fileloader import FileLoader\n\n\nclass Settings:\n    __fileloader = FileLoader()\n\n    DIRPATHS = __fileloader.DIRPATHS\n    FILEPATHS = __fileloader.FILEPATHS\n\n    DB_URL = os.getenv(\"DATABASE_URL\")\n    DB_NAME = \"\"  # Update me!\n    DB_COLLECTION_NAME = \"\"  # Update me!\n\n\nsettings = Settings()\n</code></pre>"},{"location":"getting-started/configure/#updating-the-database-model","title":"Updating The Database Model","text":"<p>Navigate to <code>backend/app/models/__init__.py</code> then update the class name <code>ExampleDB</code> to one of your choice and update its values.</p> <p>Here's a before and after for a recent project we did:</p> New To Pydantic or Beanie? <p>Check out their docs for more information:</p> <ul> <li>Pydantic</li> <li>Beanie</li> </ul> BeforeAfter __init__.py<pre><code>from typing import Optional\n\nfrom app.config.settings import settings\n\nfrom beanie import Document\nfrom pydantic import BaseModel\n\n\nclass ExampleDB(Document):\n    \"\"\"\n    The main model for your database collection. Should represent the structure of the data in the collection.\n\n    For more details check the [Beanie docs](https://beanie-odm.dev/).\n    \"\"\"\n\n    name: str\n    desc: Optional[str] = None\n\n    class Settings:\n        name = settings.DB_COLLECTION_NAME\n\n\n__beanie_models__ = [ExampleDB]\n</code></pre> __init__.py<pre><code>from typing import Optional\n\nfrom app.config.settings import settings\n\nfrom beanie import Document\nfrom pydantic import BaseModel\n\n# Other Pydantic models\n# ...\n\nclass DBSpellDetails(Document, CoreDetails):\n    \"\"\"The spell detail representation in the database.\"\"\"\n\n    desc: list[str]\n    higher_level: list[str]\n    range: str\n    components: list[str]\n    ritual: bool\n    duration: str\n    concentration: bool\n    casting_time: str\n    level: int\n    damage: Optional[DamageType] = None\n    dc: Optional[DCType] = None\n    school: CoreDetails\n    classes: list[CoreDetails]\n    subclasses: list[CoreDetails]\n\n    class Settings:\n        name = settings.DB_SPELLS_COLLECTION\n\n\n__beanie_models__ = [DBSpellDetails]\n</code></pre>"},{"location":"getting-started/configure/#where-to-go-next","title":"Where To Go Next?","text":"<p>Well done for getting this far! </p> <p>Deciding where to start with your project typically depends on your experience.</p> <p>If you are more comfortable with <code>Python</code> we recommend starting with the <code>FastAPI</code> part of the project in the <code>backend</code> directory. Start by creating your routes and models in the <code>models</code> and <code>routers</code> directories.</p> <p>More familiar with <code>React</code> and <code>NextJS</code>? Start with the <code>frontend</code> directory, specifically the <code>metadata</code> in the <code>app/layout</code> and the <code>Homepage.tsx</code> in <code>pages/Homepage</code>.</p> <p>We also recommend getting familiar with the project file structure using the links below.</p> <ul> <li> <p> Frontend</p> <p>Home to the <code>Next.js</code> files.</p> <p> Frontend file structure</p> </li> <li> <p> Backend</p> <p>Home to the <code>FastAPI</code> files.</p> <p> Backend file structure</p> </li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Before Starting</p> <p>Make sure you have <code>Docker</code> installed. </p> <p>We use the Build NextJS App Tool to create the frontend files which requires <code>Docker</code>.</p> <ol> <li> <p>Install the package through <code>PIP</code>:</p> <pre><code>pip install create_api_app\n</code></pre> </li> <li> <p>Create a new project with just a name:</p> <pre><code>create-api-app &lt;project_name&gt; # (1)!\n</code></pre> <ol> <li>Replace <code>&lt;project_name&gt;</code> with the name of your choice!</li> </ol> </li> <li> <p>Or, create a new project that excludes certain packages:</p> <pre><code>create-api-app &lt;project_name&gt; &lt;exclusions&gt; # (1)!\n</code></pre> <ol> <li>Exclusion options: <code>c</code>, <code>u</code>, <code>s</code>, <code>cs</code>, <code>cu</code>, <code>us</code>, <code>cus</code>.  <code>c</code> = <code>Clerk</code>, <code>u</code> = <code>Uploadthing</code>, <code>s</code> = <code>Stripe</code></li> </ol> <p>For example, let's say we want to create a project <code>without</code> <code>Clerk</code> and <code>Stripe</code>.</p> <p>We would do this:</p> <pre><code>create-api-app my_first_project cs\n</code></pre> </li> </ol> <p> And that's it! </p> <p>Once built, you'll find two folders: a <code>frontend</code> and a <code>backend</code>.</p> <ul> <li> <p> Frontend</p> <p>Home to the <code>Next.js</code> files.</p> <p> Frontend file structure</p> </li> <li> <p> Backend</p> <p>Home to the <code>FastAPI</code> files.</p> <p> Backend file structure</p> </li> </ul>"},{"location":"getting-started/license/","title":"License","text":"<p>Create API App is licensed under the MIT license. The MIT license is a permissive license that allows commercial use, redistribution, and everything else as long as the original authors are credited in source files.</p> <p>The MIT license is the most popular license among all Open Source projects.</p>"},{"location":"getting-started/license/#mit-license","title":"MIT License","text":"<p>The MIT License gives you the freedom to work with the code with minimal restrictions. When using Create API App, make sure to include the copyright notice and avoid future liability claims.</p> <p>Its appeal lies in its simplicity and clear terms, making it a go-to for projects of any scale. Its popularity stems from its simplicity, clarity, and development-friendly terms, making it suitable for all types of projects.</p>"},{"location":"getting-started/license/#advantages","title":"Advantages","text":"<p>The MIT License is favored for its balance between freedom and protection, appealing to those who find GNU/GPL licenses too restrictive or advocate for privatized software. Its broad wording supports both open community development and the use of components in proprietary software.</p> <p>Here\u2019s what this means for you:</p> <ul> <li>Freedom from vendor lock-in: Thanks to Open Source principles, you can use Create API App without any strings attached. Customize or integrate it into your projects without worrying about restrictions. Your projects belong to you, and you are free to change the software at any time.</li> </ul>"},{"location":"getting-started/run/","title":"Running The Project","text":"<p>In development, you need to use two separate terminal windows to run the <code>backend</code> and <code>frontend</code> independently.</p> <p>You can read more about the specific steps for each below.</p>"},{"location":"getting-started/run/#backend","title":"Backend","text":"Virtual Environment Not Working? <p>Refer to the Python documentation.</p> <ol> <li> <p>Open a terminal and navigate to the <code>backend</code> directory:</p> <pre><code>cd backend\n</code></pre> </li> <li> <p>Install a virtual environment for <code>Poetry</code>:</p> <pre><code>python -m venv env\n</code></pre> </li> <li> <p>Access it using one of the following:</p> For Windows<pre><code>.\\env\\Scripts\\activate\n</code></pre> For Mac/Linux<pre><code>source ./env/bin/activate\n</code></pre> </li> <li> <p>Run the <code>uvicorn</code> server using the <code>Poetry</code> script:</p> <pre><code>app-start\n</code></pre> </li> </ol>"},{"location":"getting-started/run/#frontend","title":"Frontend","text":"Dependency Management Options <p>While we show <code>npm</code> in the example snippets here, you don't have to use it if you don't want to. We know that <code>npm</code> is often very slow compared to other dependency managers but have found its the easiest to use on <code>Windows</code>.</p> <p>Here are a few alternatives to explore if you want something faster:</p> <ul> <li>pnpm</li> <li>yarn</li> <li>bun</li> </ul> <ol> <li> <p>Open a terminal and navigate to the <code>frontend</code> directory:</p> <pre><code>cd frontend\n</code></pre> </li> <li> <p>Install the packages using <code>Node.js</code> or the dependency manager of your choice:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the development server:</p> <pre><code>npm run dev\n</code></pre> </li> </ol>"}]}