# Backend Files

The `backend` directory is home to all the [`FastAPI`](#backend-files) and [`Poetry`](#backend-files) assets.

??? Note "Backend Folder Structure"

    ```shell title=""
    backend
    │   poetry.lock
    │   pyproject.toml
    │   README.md
    ├───app
    │   │   main.py
    │   │   start.py
    │   │   __init__.py
    │   ├───config
    │   │       __init__.py
    │   │       settings.py
    │   ├───db
    │   │       __init__.py
    │   ├───enums
    │   │       __init__.py
    │   ├───models
    │   │       __init__.py
    │   ├───routers
    │   │       __init__.py
    │   └───utils
    │           __init__.py
    │           fileloader.py
    └───tests
            __init__.py
    ```

## Root Files

At the root level, we have three files:

- [`README.md`](#backend-files) - required by `Poetry`. Holds no real value unless separating the `frontend` and `backend`
- [`pyproject.toml`](#backend-files) - the `Poetry` configuration file. Has all the information about the project and its packages. We recommend changing the `description` and `author` - we don't want credit for a project you've made!
- [`poetry.lock`](#backend-files) - the lock file that gets generated by `Poetry` when running `poetry install`. It's need to operate `Poetry` projects and is automatically updated when you use `Poetry` commands

!!! Warning
    When changing the `name` in the `pyproject.toml` remember to change the `app` directory name too! These are linked together and are required when building the project for deployment.
    
    `Poetry` has some great [documentation](https://python-poetry.org/docs/) so remember to check it out if you get stuck on anything!

## Root Directories

And two directories:

- [`app`](#backend-files) - the application files for `FastAPI`. This is the home for the `Poetry` project and the main directory you'll be working in
- [`tests`](#backend-files) - a home for your `unit and property-based tests` created with [`Hypothesis`](https://hypothesis.readthedocs.io/) and [`Pytest`](https://docs.pytest.org/)

## App Directory

The `app` directory has 2 core files in the root: [main.py](#mainpy), [start.py](#startpy).

And 6 directories: [config](#config-directory), [db](#db-directory), [enums](#enums-directory), [models](#models-directory), [routers](#routers-directory), [utils](#utils-directory).

### Main.py

The central piece of the `backend`. It handles all the functionality for the `FastAPI` app, including its `lifespan`, `middleware`, and `router` connections.

Anything directly connected to the `FastAPI` app should go in here.

=== "Project Template"

    ```python title="main.py"
    from contextlib import asynccontextmanager

    from app.db import init_db

    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware


    @asynccontextmanager
    async def lifespan(_: FastAPI):
        await init_db()
        yield


    app = FastAPI(docs_url="/api/docs", redoc_url=None, lifespan=lifespan)

    # app.include_router(root.router, prefix="/api")

    origins = [
        "",
    ]

    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_credentials=True,
        allow_methods=["GET"],
        allow_headers=["*"],
    )
    ```

=== "Working Example"

    ```python title="main.py" hl_lines="4 18 21"
    from contextlib import asynccontextmanager

    from app.db import init_db
    from app.routers import spells

    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware


    @asynccontextmanager
    async def lifespan(_: FastAPI):
        await init_db()
        yield


    app = FastAPI(docs_url="/api/docs", redoc_url=None, lifespan=lifespan)

    app.include_router(spells.router, prefix="/api") # (1)!

    origins = [
        "https://dnd.achronus.dev", # (2)!
    ]

    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_credentials=True,
        allow_methods=["GET"],
        allow_headers=["*"],
    )
    ```

    1. Connect our [`app`](#mainpy) to the [`routers`](#routers-directory) directory!
    2. Needed to connect the [`backend`](#mainpy) to the [`frontend`](#mainpy)! Check the [FastAPI docs](https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware) for more details on [`CORSMiddleware`](#mainpy)

### Start.py

The entry point for running the `uvicorn` server. When calling the `app-start` command in the `backend` directory, this activates the `run` function.

This file typically won't need to be touched until you are looking at deploying your project. Here's what it looks like:

```python title="start.py"
import argparse

import uvicorn


def run(env_mode: str = "dev", host: str = "127.0.0.1", port: int = 8000) -> None:
    """Start the server."""
    dev_mode = True if env_mode == "dev" else False

    uvicorn.run(
        "app.main:app",
        host=host,
        port=port,
        reload=dev_mode,
        reload_includes="*",
    )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Start the server.")
    parser.add_argument(
        "-e", "--env", type=str, default="dev", choices=["dev", "prod"], required=True
    )
    parser.add_argument("-ht", "--host", type=str, default="127.0.0.1", required=False)
    parser.add_argument("-pt", "--port", type=int, default=8000, required=False)

    args = parser.parse_args()
    run(args.env, args.host, args.port)
```

### Config Directory

This directory is intended for `configuration` files and `constant` variables.

It houses a critical object for the application called the `Settings` class in the `settings.py` file. We use this to access the static `config` values across the application, such as the `database` details retrieved from the `.env.local` file.

Here's what it looks like:

```python title="config/settings.py"
import os

from app.utils.fileloader import FileLoader # (1)!


class Settings:
    __fileloader = FileLoader()

    DIRPATHS = __fileloader.DIRPATHS
    FILEPATHS = __fileloader.FILEPATHS

    DB_URL = os.getenv("DATABASE_URL")
    DB_NAME = ""  # Update me!
    DB_COLLECTION_NAME = ""  # Update me!


settings = Settings()  # (2)!
```

1. Required for loading the [`DB_URL`](#config-directory) from the [`.env.local`](root.md#environment-file) file
2. We use this to access the [`settings`](#config-directory) object in the project!

### DB Directory

Houses the `database` files, such as the connection to the [`MongoDB`](https://www.mongodb.com/) database using an `AsyncIOMotorClient` and the [`Beanie`](https://beanie-odm.dev/) ODM initalization.

It has one file (`__init__.py`) with this functionality already built in and connected to the `FastAPI` app.

!!! info
    Remember the [`lifespan`](#mainpy) function in [`main.py`](#mainpy)? This connects directly to that!

Here's what it looks like:

```python title="db/__init__.py"
from app.models import __beanie_models__
from app.config.settings import settings

from beanie import init_beanie
from motor.motor_asyncio import AsyncIOMotorClient


async def init_db() -> None:
    """Initialises the database."""
    client = AsyncIOMotorClient(settings.DB_URL)
    database = client[settings.DB_NAME]
    await init_beanie(database=database, document_models=__beanie_models__)
```

### Enums Directory

This folder is dedicated to Python [Enums](https://docs.python.org/3/library/enum.html). These are great to use with [Pydantic](https://docs.pydantic.dev/latest/concepts/models/) models for limiting an `attribute` to predefined `options`.

For example, let's say you have a route that has a set of [query] parameters and you want to limit them to a predefined set of options.

??? question "What are query parameters?"
    Have you ever seen values after a `?` in a url, such as `page=1` or `per_page=12`?
    
    Well, those are `query` parameters! They are used in `frontend` applications as a form of `state`. I'll leave the [FastAPI documentation](https://fastapi.tiangolo.com/tutorial/query-params/) to explain them!

You can create an `Enum` like so:

```python title="enums/__init__.py"
from enum import StrEnum


class CommonQueryKeys(StrEnum):
    """An enum for common query keys."""

    LIMIT = "limit"
    SKIP = "skip"
```

### Models Directory

This folder houses your [Pydantic](https://docs.pydantic.dev/latest/concepts/models/) and [Beanie](https://beanie-odm.dev/tutorial/defining-a-document/) models. You'll be here a lot!

The [`Beanie`](#models-directory) models focus on representing what the [`MongoDB`](#models-directory) database looks like, while the [`Pydantic`](#models-directory) models are used for handling data.

??? Example "Beanie Models"
    === "Project Template"
    
        ```python title="models/__init__.py"
        from typing import Optional

        from app.config.settings import settings

        from beanie import Document
        from pydantic import BaseModel


        class ExampleDB(Document):
            """
            The main model for your database collection. 
            Should represent the structure of the data in the collection.

            For more details check the [Beanie docs](https://beanie-odm.dev/).
            """

            name: str
            desc: Optional[str] = None

            class Settings:
                name = settings.DB_COLLECTION_NAME


        __beanie_models__ = [ExampleDB]
        ```

    === "Real Example"

        ```python title="models/__init__.py"
        from typing import Optional

        from app.config.settings import settings

        from beanie import Document
        from pydantic import BaseModel


        class DBSpellDetails(Document, CoreDetails):
            """The spell detail representation in the database."""

            desc: list[str]
            higher_level: list[str]
            range: str
            components: list[str]
            ritual: bool
            duration: str
            concentration: bool
            casting_time: str
            level: int
            damage: Optional[DamageType] = None
            dc: Optional[DCType] = None
            school: CoreDetails
            classes: list[CoreDetails]
            subclasses: list[CoreDetails]

            class Settings:
                name = settings.DB_SPELLS_COLLECTION


        __beanie_models__ = [DBSpellDetails]
        ```

??? Example "Pydantic Models"

    === "DB Example"
    
        These models connect to the `DBSpellDetails` document in the `Beanie Models - Real Example`!

        ```python title="models/__init__.py"
        from typing import Optional

        from pydantic import BaseModel


        class CoreDetails(BaseModel):
            index: str
            name: str
            url: str


        class DamageType(BaseModel):
            damage_type: Optional[CoreDetails] = None
            damage_at_character_level: Optional[dict[str, str]] = None


        class DCType(BaseModel):
            dc_type: dict[str, str]
            dc_success: str
        ```

    === "Route Example"

        We use some of these in the [routers example](#routers-directory)!

        ```python title="models/routing.py" hl_lines="20-25"
        from typing import Optional

        from app.enums import (
            Classes,
            Components,
            DamageTypes,
            Levels,
            MagicSchools,
            Subclasses,
        )
        from app.models import CoreDetails, DCType, DamageType
        from pydantic import BaseModel, ConfigDict


        class SpellOverviewInput(BaseModel):
            """A model that represents the query parameters for the `spells_overview` route."""

            limit: Optional[int] = None
            skip: Optional[int] = None
            classes: Optional[Classes] = None
            subclass: Optional[Subclasses] = None 
            components: Optional[Components] = None # (1)!
            level: Optional[Levels] = None
            school: Optional[MagicSchools] = None
            damage_type: Optional[DamageTypes] = None

            model_config = ConfigDict(use_enum_values=True)


        class SpellNames(BaseModel):
        """A model for retrieving all the spell names."""

        name: str


        class SpellDetailsResponse(BaseModel):
            """A model that represents the spell details for each spell."""

            name: str
            index: str
            desc: list[str]
            higher_level: list[str]
            range: str
            components: list[str]
            ritual: bool
            duration: str
            concentration: bool
            casting_time: str
            level: int
            damage: Optional[DamageType] = None
            dc: Optional[DCType] = None
            school: CoreDetails
            classes: list[CoreDetails]
            subclasses: list[CoreDetails]
        ```

        1. These use Python [`Enums`](#models-directory)!

### Routers Directory

This directory houses all the [`FastAPI routes`](https://fastapi.tiangolo.com/tutorial/bigger-applications/) by making use of the [`APIRouter`](https://fastapi.tiangolo.com/tutorial/bigger-applications/#import-apirouter).

For example, let's say we have a set of `spells` in our database and we want to create two routes:

- One to pull a list of their `names` from the database. Accessed at the url - `/api/spells/names`
- And another for accessing each spells information individually using their `index`. Accessable at the url - `/api/spells/{index}`

We can do this easily by creating a `spells` router, assigning it the `/spells` prefix and then attach our routes using its name.

Here's what that would look like:

```python title="routers/spells.py" hl_lines="7 10 21"
from app.models import DBSpellDetails
from app.models.local import SpellNames, SpellDetailsResponse

from fastapi import HTTPException, APIRouter


router = APIRouter(prefix="/spells", tags=["spells"]) # (1)!


@router.get("/names", response_model=list[SpellNames] | list[str]) # (2)!
async def spell_names():
    result = await DBSpellDetails.find_all().to_list()

    if result is None:
        raise HTTPException(status_code=404, detail="Cannot retrieve data.")

    names = ["-".join(name.name.lower().split(" ")) for name in result]
    return names


@router.get("/{index}", response_model=SpellDetailsResponse) # (3)!
async def spell_details(index: str):
    result = await DBSpellDetails.find_one(DBSpellDetails.index == index)

    if result is None:
        raise HTTPException(status_code=404, detail="Item not found.")

    return result
```

1. Create a `router` using the `APIRouter`
2. Create our first route that points to `/api/spells/names`
3. Create our second route that points to `/api/spells/{index}`

Now we just need to go back into the [`main.py`](#__tabbed_1_2) file and connect it to our `app`!

```python title="app/main.py" hl_lines="4"
# Imports and other config
# ...

app.include_router(spells.router, prefix="/api") # (1)!

# Origins
# ...
```

1. Notice the `prefix`? This prepends `/api` to the `spells` router to make it direct to `api/spells/`!

### Utils Directory

A place to store `utility` functions.

It comes preconfigured with a [`Fileloader`](#utils-directory) class for finding and loading the [`.env.local`](root.md#environment-file) file used in [`config/settings.py`](#config-directory) for retrieving the [`DB_URL`](#utils-directory). You don't need to amend this file.
